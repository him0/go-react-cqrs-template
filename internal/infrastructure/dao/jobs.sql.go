// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: jobs.sql

package dao

import (
	"context"
	"database/sql"
	"encoding/json"
	"time"
)

const countJobsByStatus = `-- name: CountJobsByStatus :one
SELECT COUNT(*) FROM jobs WHERE status = $1
`

func (q *Queries) CountJobsByStatus(ctx context.Context, status string) (int64, error) {
	row := q.db.QueryRowContext(ctx, countJobsByStatus, status)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const deleteCompletedJobsBefore = `-- name: DeleteCompletedJobsBefore :exec
DELETE FROM jobs
WHERE status IN ('completed', 'dead')
  AND completed_at < $1
`

func (q *Queries) DeleteCompletedJobsBefore(ctx context.Context, completedAt sql.NullTime) error {
	_, err := q.db.ExecContext(ctx, deleteCompletedJobsBefore, completedAt)
	return err
}

const enqueueJob = `-- name: EnqueueJob :exec
INSERT INTO jobs (id, job_type, payload, status, max_attempts, scheduled_at, created_at, updated_at)
VALUES ($1, $2, $3, 'pending', $4, $5, $6, $7)
`

type EnqueueJobParams struct {
	ID          string          `db:"id" json:"id"`
	JobType     string          `db:"job_type" json:"job_type"`
	Payload     json.RawMessage `db:"payload" json:"payload"`
	MaxAttempts int32           `db:"max_attempts" json:"max_attempts"`
	ScheduledAt time.Time       `db:"scheduled_at" json:"scheduled_at"`
	CreatedAt   time.Time       `db:"created_at" json:"created_at"`
	UpdatedAt   time.Time       `db:"updated_at" json:"updated_at"`
}

func (q *Queries) EnqueueJob(ctx context.Context, arg EnqueueJobParams) error {
	_, err := q.db.ExecContext(ctx, enqueueJob,
		arg.ID,
		arg.JobType,
		arg.Payload,
		arg.MaxAttempts,
		arg.ScheduledAt,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	return err
}

const fetchJobs = `-- name: FetchJobs :many
SELECT id, job_type, payload, status, attempts, max_attempts, last_error,
       scheduled_at, started_at, completed_at, created_at, updated_at
FROM jobs
WHERE status IN ('pending', 'retryable')
  AND scheduled_at <= NOW()
ORDER BY scheduled_at ASC
LIMIT $1
FOR UPDATE SKIP LOCKED
`

func (q *Queries) FetchJobs(ctx context.Context, limit int32) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, fetchJobs, limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.Payload,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getJobByID = `-- name: GetJobByID :one
SELECT id, job_type, payload, status, attempts, max_attempts, last_error,
       scheduled_at, started_at, completed_at, created_at, updated_at
FROM jobs
WHERE id = $1
`

func (q *Queries) GetJobByID(ctx context.Context, id string) (Job, error) {
	row := q.db.QueryRowContext(ctx, getJobByID, id)
	var i Job
	err := row.Scan(
		&i.ID,
		&i.JobType,
		&i.Payload,
		&i.Status,
		&i.Attempts,
		&i.MaxAttempts,
		&i.LastError,
		&i.ScheduledAt,
		&i.StartedAt,
		&i.CompletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listJobsByStatus = `-- name: ListJobsByStatus :many
SELECT id, job_type, payload, status, attempts, max_attempts, last_error,
       scheduled_at, started_at, completed_at, created_at, updated_at
FROM jobs
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListJobsByStatusParams struct {
	Status string `db:"status" json:"status"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) ListJobsByStatus(ctx context.Context, arg ListJobsByStatusParams) ([]Job, error) {
	rows, err := q.db.QueryContext(ctx, listJobsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Job{}
	for rows.Next() {
		var i Job
		if err := rows.Scan(
			&i.ID,
			&i.JobType,
			&i.Payload,
			&i.Status,
			&i.Attempts,
			&i.MaxAttempts,
			&i.LastError,
			&i.ScheduledAt,
			&i.StartedAt,
			&i.CompletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markJobCompleted = `-- name: MarkJobCompleted :exec
UPDATE jobs
SET status = 'completed', completed_at = NOW(), updated_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkJobCompleted(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markJobCompleted, id)
	return err
}

const markJobDead = `-- name: MarkJobDead :exec
UPDATE jobs
SET status = 'dead', last_error = $2, completed_at = NOW(), updated_at = NOW()
WHERE id = $1
`

type MarkJobDeadParams struct {
	ID        string         `db:"id" json:"id"`
	LastError sql.NullString `db:"last_error" json:"last_error"`
}

func (q *Queries) MarkJobDead(ctx context.Context, arg MarkJobDeadParams) error {
	_, err := q.db.ExecContext(ctx, markJobDead, arg.ID, arg.LastError)
	return err
}

const markJobProcessing = `-- name: MarkJobProcessing :exec
UPDATE jobs
SET status = 'processing', started_at = NOW(), attempts = attempts + 1, updated_at = NOW()
WHERE id = $1
`

func (q *Queries) MarkJobProcessing(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, markJobProcessing, id)
	return err
}

const markJobRetryable = `-- name: MarkJobRetryable :exec
UPDATE jobs
SET status = 'retryable', last_error = $2, scheduled_at = $3, updated_at = NOW()
WHERE id = $1
`

type MarkJobRetryableParams struct {
	ID          string         `db:"id" json:"id"`
	LastError   sql.NullString `db:"last_error" json:"last_error"`
	ScheduledAt time.Time      `db:"scheduled_at" json:"scheduled_at"`
}

func (q *Queries) MarkJobRetryable(ctx context.Context, arg MarkJobRetryableParams) error {
	_, err := q.db.ExecContext(ctx, markJobRetryable, arg.ID, arg.LastError, arg.ScheduledAt)
	return err
}
